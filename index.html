<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thermal Printer TTRPG Card Generator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- html2canvas CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* bg-gray-900 equivalent */
            color: #e2e8f0; /* text-gray-100 equivalent */
        }
        /* Basic markdown-like styling for preview */
        .card-content strong { font-weight: 700; }
        .card-content em { font-style: italic; }
        .card-content a { color: #63b3ed; text-decoration: underline; }
        /* Style for Font Awesome icons in preview */
        .card-icon-fa {
            font-size: 48px; /* Larger size for visibility */
            color: #4a6898; /* Example color, adjust as needed */
            margin-bottom: 8px;
        }
    </style>
</head>
<body class="min-h-screen p-4 flex flex-col items-center">

    <div id="main-generator-view">
        <!-- Service Worker Registration -->
        <script>
            // Service Worker content as a string
            const swContent = `
                const CACHE_NAME = 'ttrpg-card-printer-cache-v1';
                const urlsToCache = [
                  './', // Cache the current HTML file
                  // If you have other assets (like icons) served relative to this HTML file, list them here:
                  // './icon-192x192.png',
                  // './icon-512x512.png',
                ];

                self.addEventListener('install', (event) => {
                  event.waitUntil(
                    caches.open(CACHE_NAME)
                      .then((cache) => {
                        console.log('Opened cache');
                        return cache.addAll(urlsToCache);
                      })
                      .catch(error => console.error('Service Worker cache addAll failed:', error))
                  );
                });

                self.addEventListener('fetch', (event) => {
                  event.respondWith(
                    caches.match(event.request)
                      .then((response) => {
                        if (response) {
                          return response;
                        }
                        return fetch(event.request);
                      })
                  );
                });
            `;

            // Register service worker using a Blob URL, only if in a secure context or localhost
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    if (window.location.protocol === 'https:' || window.location.hostname === 'localhost') {
                        const swBlob = new Blob([swContent], { type: 'application/javascript' });
                        const swUrl = URL.createObjectURL(swBlob);

                        navigator.serviceWorker.register(swUrl)
                            .then(registration => console.log('Service Worker registered:', registration))
                            .catch(error => console.error('Service Worker registration failed:', error));
                    } else {
                        console.warn('Service Worker not registered: PWA features (like offline mode) require HTTPS or localhost.');
                    }
                });
            }
        </script>

        <h1 class="text-3xl font-bold mb-6 text-center text-purple-400">Thermal Printer TTRPG Card Generator</h1>

        <div id="message-display" class="hidden bg-blue-500 text-white p-3 rounded-md mb-4 text-center w-full max-w-md"></div>

        <!-- Card Navigation Section -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl mb-6 w-full max-w-2xl">
            <h2 class="text-2xl font-semibold mb-4 text-purple-300">Navigate Cards</h2>
            <div class="flex items-center space-x-4 mb-4">
                <button id="prev-card-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md disabled:opacity-50 disabled:cursor-not-allowed">Previous</button>
                <select id="card-select" class="flex-grow p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
                    <!-- Options will be populated by JS -->
                </select>
                <button id="next-card-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md disabled:opacity-50 disabled:cursor-not-allowed">Next</button>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <button id="add-new-card-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg">Add New Empty Card</button>
                <button id="open-import-modal-btn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg">Import Cards</button>
            </div>
        </div>

        <!-- Card Input Section -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl mb-6 w-full max-w-2xl">
            <h2 class="text-2xl font-semibold mb-4 text-purple-300">Card Details</h2>

            <div class="mb-4">
                <label for="title" class="block text-sm font-medium text-gray-300 mb-1">Card Title</label>
                <input type="text" id="title" name="title" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
            </div>

            <div class="mb-4">
                <label for="type" class="block text-sm font-medium text-gray-300 mb-1">Card Type</label>
                <input type="text" id="type" name="type" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
            </div>

            <div class="mb-4">
                <div class="flex justify-between items-center mb-1">
                    <label for="icon" class="block text-sm font-medium text-gray-300">Icon Name or Image URL</label>
                    <a href="https://game-icons.net/" target="_blank" class="text-xs text-purple-400 hover:underline">Full list of icons...</a>
                </div>
                <input type="text" id="icon" name="icon" list="icon-suggestions" placeholder="e.g., magic-swirl or https://example.com/icon.png" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
                <datalist id="icon-suggestions">
                    <!-- Options will be populated by JS -->
                </datalist>
            </div>

            <div class="mb-4">
                <label for="color" class="block text-sm font-medium text-gray-300 mb-1">Card Color (Hex, Optional)</label>
                <input type="color" id="color" name="color" value="#ffffff" class="w-full h-10 rounded-md bg-gray-700 border border-gray-600">
            </div>

            <!-- Dynamic Sections -->
            <div class="mb-4 border-t border-gray-700 pt-4">
                <h3 class="text-xl font-semibold mb-3 text-purple-300">Content Sections</h3>
                <div id="sections-container">
                    <!-- Sections will be dynamically added here -->
                </div>
                <button id="add-section-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md w-full">Add Section</button>
            </div>

            <!-- Stats -->
            <div class="mb-4 border-t border-gray-700 pt-4">
                <h3 class="text-xl font-semibold mb-3 text-purple-300">Stats (Key-Value Pairs)</h3>
                <div id="stats-container">
                    <!-- Stats will be dynamically added here -->
                </div>
                <button id="add-stat-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md w-full">Add Stat</button>
            </div>

            <!-- Tags and Footer -->
            <div class="mb-4 border-t border-gray-700 pt-4">
                <label for="tags" class="block text-sm font-medium text-gray-300 mb-1">Tags (Comma-separated)</label>
                <input type="text" id="tags" name="tags" placeholder="e.g., Fire, Spell, Evocation" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
            </div>

            <div class="mb-4">
                <label for="footer" class="block text-sm font-medium text-gray-300 mb-1">Footer Text (Optional)</label>
                <input type="text" id="footer" name="footer" placeholder="e.g., Source: PHB" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
            </div>

            <!-- Folded Card Options -->
            <div class="mb-4 border-t border-gray-700 pt-4">
                <h3 class="text-xl font-semibold mb-3 text-purple-300">Card Folding</h3>
                <label class="inline-flex items-center">
                    <input type="checkbox" id="is-folded" name="isFolded" class="form-checkbox h-5 w-5 text-purple-600 rounded">
                    <span class="ml-2 text-gray-300">Folded Card</span>
                </label>

                <div id="fold-content-options" class="mt-4 bg-gray-700 p-4 rounded-md hidden">
                    <h4 class="text-lg font-semibold mb-2 text-purple-200">Back/Bottom Fold Content</h4>
                    <div class="mb-3">
                        <label for="fold-content-type" class="block text-sm font-medium text-gray-300 mb-1">Content Type</label>
                        <select id="fold-content-type" name="foldContentType" class="w-full p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500">
                            <option value="text">Text</option>
                            <option value="imageUrl">Image URL</option>
                            <option value="qrCode">QR Code</option>
                        </select>
                    </div>

                    <div id="fold-text-input" class="mb-3">
                        <label for="fold-content-text" class="block text-sm font-medium text-gray-300 mb-1">Text for Fold</label>
                        <textarea id="fold-content-text" name="foldContentText" rows="3" class="w-full p-2 rounded-md bg-gray-600 border border-gray-500" placeholder="Content for the back of the folded card."></textarea>
                    </div>
                    <div id="fold-image-input" class="mb-3 hidden">
                        <label for="fold-content-image-url" class="block text-sm font-medium text-gray-300 mb-1">Image URL or Icon Name for Fold</label>
                        <input type="text" id="fold-content-image-url" name="foldContentImageUrl" list="icon-suggestions" class="w-full p-2 rounded-md bg-gray-600 border border-gray-500" placeholder="e.g., swords or https://example.com/back_design.png">
                    </div>
                    <div id="fold-qr-input" class="mb-3 hidden">
                        <label for="fold-content-qr-data" class="block text-sm font-medium text-gray-300 mb-1">QR Code Data</label>
                        <input type="text" id="fold-content-qr-data" name="foldContentQrCodeData" class="w-full p-2 rounded-md bg-gray-600 border border-gray-500" placeholder="https://your-game-link.com">
                    </div>
                </div>
            </div>
        </div>

        <!-- Printer Settings & Preview -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl mb-6 w-full max-w-2xl">
            <h2 class="text-2xl font-semibold mb-4 text-purple-300">Printer Settings & Preview</h2>

            <div class="mb-4">
                <label for="printer-type" class="block text-sm font-medium text-gray-300 mb-1">Select Printer Type</label>
                <select type="text" id="printer-type" name="printerType" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
                    <option value="thermal">Thermal Receipt Printer (Monochrome)</option>
                    <option value="color">Color Photo Printer (Kodak Zink / Fujifilm Instax)</option>
                </select>
            </div>

            <div id="thermal-paper-size-container" class="mb-4">
                <label for="thermal-paper-size" class="block text-sm font-medium text-gray-300 mb-1">Thermal Paper Size</label>
                <select id="thermal-paper-size" name="thermalPaperSize" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
                    <option value="58mm">58mm (Print Width ~48mm)</option>
                    <option value="80mm">80mm (Print Width ~72mm)</option>
                </select>
            </div>

            <div id="thermal-dpi-container" class="mb-4">
                <label for="thermal-dpi" class="block text-sm font-medium text-gray-300 mb-1">Thermal Printer DPI</label>
                <select id="thermal-dpi" name="thermalDpi" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
                    <option value="203">203 DPI (Standard)</option>
                    <option value="180">180 DPI</option>
                    <option value="200">200 DPI</option>
                    <option value="300">300 DPI</option>
                </select>
            </div>

            <div class="mb-4">
                <label for="num-copies" class="block text-sm font-medium text-gray-300 mb-1">Number of Copies (1-10)</label>
                <input type="number" id="num-copies" name="numCopies" min="1" max="10" value="1" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
            </div>

            <!-- Card Preview Area -->
            <div id="card-preview-container" class="p-4 rounded-lg shadow-lg border-2 overflow-hidden">
                <h3 class="text-xl font-bold mb-2 text-center" id="preview-title">Card Preview (Monochrome)</h3>
                <div id="card-front-preview" class="relative mx-auto p-2 border border-dashed border-gray-400 rounded-md min-h-[150px] flex flex-col justify-between">
                    <!-- Card front content will be rendered here -->
                </div>
                <div id="card-back-preview-container" class="mt-4 hidden">
                    <h3 class="text-xl font-bold mb-2 text-center">Folded Back Preview (Rotated 180Â°)</h3>
                    <div id="card-back-preview" class="relative mx-auto p-2 border border-dashed border-gray-400 rounded-md min-h-[100px] flex flex-col justify-center items-center transform rotate-180">
                        <!-- Card back content will be rendered here -->
                    </div>
                </div>
            </div>

            <div class="mt-6 flex flex-col space-y-3">
                <label class="block text-sm font-medium text-gray-300">Print/Export Scope:</label>
                <div class="flex space-x-4 mb-4">
                    <label class="inline-flex items-center">
                        <input type="radio" name="printScope" value="current" checked class="form-radio h-4 w-4 text-purple-600">
                        <span class="ml-2 text-gray-300">Current Card</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="printScope" value="all" class="form-radio h-4 w-4 text-purple-600">
                        <span class="ml-2 text-gray-300">All Cards</span>
                    </label>
                </div>

                <button id="view-card-btn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">View Card</button>
                <a id="print-thermal-btn" href="#" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 text-center">Print to Thermal Printer</a>
                <button id="print-color-photo-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 hidden">Print Color Photo Card</button>
                <button id="download-image-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Download Image</button>
                <button id="share-card-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Share Card</button>
                <button id="copy-bookmark-link-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Copy Bookmarkable Link</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="import-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-2xl max-h-full overflow-y-auto relative">
            <button id="close-import-modal-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
            <h2 class="text-3xl font-bold mb-6 text-center text-purple-400">Import Card Data</h2>

            <div class="space-y-6">
                <!-- 5e.tools File Accordion -->
                <div class="border-b border-gray-700">
                    <button id="accordion-file-import-heading" class="w-full flex justify-between items-center py-4 text-left text-lg font-semibold text-purple-300 hover:text-purple-200">
                        <span>Import from 5e.tools (.json file)</span>
                        <i class="fas fa-chevron-down transition-transform duration-300 rotate-180"></i>
                    </button>
                    <div id="accordion-file-import-content" class="pt-2 pb-4">
                        <input type="file" id="rpg-cards-json-file" accept=".json,application/json,application/octet-stream,text/plain" class="w-full text-gray-300 bg-gray-900 rounded-lg p-3 border border-gray-600 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-500 file:text-white hover:file:bg-purple-600 transition-colors">
                    </div>
                </div>

                <!-- 5e.tools Accordion -->
                <div class="border-b border-gray-700">
                    <button id="accordion-5e-tools-heading" class="w-full flex justify-between items-center py-4 text-left text-lg font-semibold text-purple-300 hover:text-purple-200">
                        <span>Paste JSON from 5e.tools</span>
                        <i class="fas fa-chevron-down transition-transform duration-300"></i>
                    </button>
                    <div id="accordion-5e-tools-content" class="hidden pt-2 pb-4">
                        <textarea id="5e-tools-json-paste" rows="6" class="w-full p-3 rounded-lg bg-gray-900 border border-gray-600 focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition-shadow" placeholder="Paste your 5e.tools JSON here..."></textarea>
                        <p class="mt-2 text-xs text-gray-400">
                            <strong>Expected format:</strong> A single JSON object for a creature or an array of creature objects. Typically includes keys like `name`, `hp`, `ac`, `trait`, `action`, etc.
                            <br>Example: <code class="text-xs bg-gray-700 p-1 rounded">{"name": "Goblin", "hp": {"average": 7, "formula": "2d6"}, ...}</code>
                        </p>
                    </div>
                </div>

                <!-- Generic JSON Accordion -->
                <div class="border-b border-gray-700">
                    <button id="accordion-generic-json-heading" class="w-full flex justify-between items-center py-4 text-left text-lg font-semibold text-purple-300 hover:text-purple-200">
                        <span>Paste Generic Card JSON</span>
                        <i class="fas fa-chevron-down transition-transform duration-300"></i>
                    </button>
                    <div id="accordion-generic-json-content" class="hidden pt-2 pb-4">
                        <textarea id="generic-json-paste" rows="6" class="w-full p-3 rounded-lg bg-gray-900 border border-gray-600 focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition-shadow" placeholder="Paste any other TTRPG card JSON here..."></textarea>
                        <p class="mt-2 text-xs text-gray-400">
                            <strong>Expected format:</strong> A JSON object (or array of objects) that matches the internal card structure. Key fields include `title`, `type`, `icon`, `color`, `tags`, `footer`, `stats` (as an object), and `sections` (as an array of objects with `heading`, `body`, `flavorText`).
                            <br>Example: <code class="text-xs bg-gray-700 p-1 rounded">{"title": "Fireball", "type": "Spell", "sections": [{"heading": "Description", "body": "A fiery explosion..."}]}</code>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="card-view" class="hidden">
        <!-- This area is populated by the initCardView function -->
    </div>

    <script>
        // Global application state
        let iconManifest = {}; // To be populated from icon-lookup.json
        let appState = {
            cards: [ // Array to hold all cards
                {
                    id: '',
                    title: 'New Card',
                    type: 'Spell',
                    icon: '', // This will now store the Font Awesome class name or a keyword
                    color: '#ffffff',
                    tags: [],
                    sections: [
                        { heading: 'Description', body: 'This is a magical card.', flavorText: '' }
                    ],
                    cost: '',
                    rarity: '',
                    abilities: [],
                    image: '', // This field is not directly used for display in the current preview, but kept for data integrity
                    stats: {},
                    footer: 'Custom Card',
                    isFolded: false,
                    foldContent: {
                        type: 'text',
                        text: 'Folded content goes here.',
                        imageUrl: '', // This will store the URL for the back image (e.g., from icon_back)
                        qrCodeData: ''
                    }
                }
            ],
            currentCardIndex: 0, // Index of the currently displayed card
            printerType: 'thermal', // 'thermal' or 'color'
            thermalPaperSize: '58mm', // '58mm', '80mm'
            numCopies: 1, // Number of copies for the current card
            printScope: 'current', // 'current' or 'all'
            thermalDpi: 203, // 180, 200, 203, 300
            rememberedIcons: []
        };

        // DOM Elements (defined after appState for clarity, but before functions that use them)
        const messageDisplay = document.getElementById('message-display');
        const titleInput = document.getElementById('title');
        const typeInput = document.getElementById('type');
        const iconInput = document.getElementById('icon');
        const colorInput = document.getElementById('color');
        const sectionsContainer = document.getElementById('sections-container');
        const addSectionBtn = document.getElementById('add-section-btn');
        const statsContainer = document.getElementById('stats-container');
        const addStatBtn = document.getElementById('add-stat-btn');
        const tagsInput = document.getElementById('tags');
        const footerInput = document.getElementById('footer');
        const isFoldedCheckbox = document.getElementById('is-folded');
        const foldContentOptions = document.getElementById('fold-content-options');
        const foldContentTypeSelect = document.getElementById('fold-content-type');
        const foldTextInput = document.getElementById('fold-text-input');
        const foldImageInput = document.getElementById('fold-image-input');
        const foldQrInput = document.getElementById('fold-qr-input');
        const foldContentTextarea = document.getElementById('fold-content-text');
        const foldContentImageUrlInput = document.getElementById('fold-content-image-url');
        const foldContentQrDataInput = document.getElementById('fold-content-qr-data');
        const rpgCardsJsonFile = document.getElementById('rpg-cards-json-file');
        const eToolsJsonPaste = document.getElementById('5e-tools-json-paste');
        const genericJsonPaste = document.getElementById('generic-json-paste');
        const printerTypeSelect = document.getElementById('printer-type');
        const thermalPaperSizeContainer = document.getElementById('thermal-paper-size-container');
        const thermalDpiContainer = document.getElementById('thermal-dpi-container');
        const thermalPaperSizeSelect = document.getElementById('thermal-paper-size');
        const thermalDpiSelect = document.getElementById('thermal-dpi');
        const numCopiesInput = document.getElementById('num-copies'); // New
        const cardPreviewContainer = document.getElementById('card-preview-container');
        const previewTitle = document.getElementById('preview-title');
        const cardFrontPreview = document.getElementById('card-front-preview');
        const cardBackPreviewContainer = document.getElementById('card-back-preview-container');
        const cardBackPreview = document.getElementById('card-back-preview');
        const printThermalBtn = document.getElementById('print-thermal-btn');
        const viewCardBtn = document.getElementById('view-card-btn');
        const printColorPhotoBtn = document.getElementById('print-color-photo-btn');
        const downloadImageBtn = document.getElementById('download-image-btn');
        const shareCardBtn = document.getElementById('share-card-btn');
        const copyBookmarkLinkBtn = document.getElementById('copy-bookmark-link-btn');

        // Card Navigation Elements
        const prevCardBtn = document.getElementById('prev-card-btn');
        const nextCardBtn = document.getElementById('next-card-btn');
        const cardSelect = document.getElementById('card-select');
        const addNewCardBtn = document.getElementById('add-new-card-btn');
        const openImportModalBtn = document.getElementById('open-import-modal-btn');

        // Import Modal Elements
        const importModal = document.getElementById('import-modal');
        const closeImportModalBtn = document.getElementById('close-import-modal-btn');
        const accordionFileImportHeading = document.getElementById('accordion-file-import-heading');
        const accordionFileImportContent = document.getElementById('accordion-file-import-content');
        const accordion5eToolsHeading = document.getElementById('accordion-5e-tools-heading');
        const accordion5eToolsContent = document.getElementById('accordion-5e-tools-content');
        const accordionGenericJsonHeading = document.getElementById('accordion-generic-json-heading');
        const accordionGenericJsonContent = document.getElementById('accordion-generic-json-content');

        // Print Scope Radio Buttons
        const printScopeRadios = document.querySelectorAll('input[name="printScope"]');


        // Utility functions (defined first to ensure availability)
        function formatText(text) {
            if (!text) return '';
            let formattedText = text;
            formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // Bold
            formattedText = formattedText.replace(/\*(.*?)\*/g, '<em>$1</em>'); // Italic
            formattedText = formattedText.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'); // Links
            formattedText = formattedText.replace(/\n/g, '<br />'); // Newlines
            return formattedText;
        }

        function showMessage(msg, isError = false) {
            messageDisplay.textContent = msg;
            messageDisplay.classList.remove('hidden', 'bg-blue-500', 'bg-red-500');
            messageDisplay.classList.add(isError ? 'bg-red-500' : 'bg-blue-500');
            setTimeout(() => {
                messageDisplay.classList.add('hidden');
            }, 5000);
        }

        // Function to determine if a string is a URL
        function isURL(str) {
            try {
                new URL(str);
                return true;
            } catch (_) {
                return false;
            }
        }

        // Render functions (called by updateUIFromAppState and event handlers)
        function renderSections() {
            const currentCard = appState.cards[appState.currentCardIndex];
            sectionsContainer.innerHTML = '';
            const sectionsToRender = Array.isArray(currentCard.sections) ? currentCard.sections : [];

            sectionsToRender.forEach((section, index) => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'bg-gray-700 p-4 rounded-md mb-3 relative';
                sectionDiv.innerHTML = `
                    <button data-index="${index}" class="remove-section-btn absolute top-2 right-2 bg-red-600 hover:bg-red-700 text-white text-xs font-bold py-1 px-2 rounded-full">X</button>
                    <label for="section-heading-${index}" class="block text-sm font-medium text-gray-300 mb-1">Heading (Optional)</label>
                    <input type="text" id="section-heading-${index}" data-field="heading" data-index="${index}" value="${section.heading || ''}" class="section-input w-full p-2 rounded-md bg-gray-600 border border-gray-500 mb-2">
                    <label for="section-body-${index}" class="block text-sm font-medium text-gray-300 mb-1">Body Text (Markdown-like)</label>
                    <textarea id="section-body-${index}" data-field="body" data-index="${index}" rows="4" class="section-input w-full p-2 rounded-md bg-gray-600 border border-gray-500 mb-2" placeholder="Use **bold**, *italic*, and newlines.">${section.body || ''}</textarea>
                    <label for="section-flavorText-${index}" class="block text-sm font-medium text-gray-300 mb-1">Flavor Text (Optional)</label>
                    <textarea id="section-flavorText-${index}" data-field="flavorText" data-index="${index}" rows="2" class="section-input w-full p-2 rounded-md bg-gray-600 border border-gray-500" placeholder="Optional italicized text.">${section.flavorText || ''}</textarea>
                `;
                sectionsContainer.appendChild(sectionDiv);
            });
            document.querySelectorAll('.section-input').forEach(input => {
                input.addEventListener('input', handleSectionChange);
            });
            document.querySelectorAll('.remove-section-btn').forEach(button => {
                button.addEventListener('click', handleRemoveSection);
            });
            updateCardPreview();
        }

        function handleSectionChange(event) {
            const index = parseInt(event.target.dataset.index);
            const field = event.target.dataset.field;
            appState.cards[appState.currentCardIndex].sections[index][field] = event.target.value;
            saveState();
            updateCardPreview();
        }

        function handleRemoveSection(event) {
            const index = parseInt(event.target.dataset.index);
            appState.cards[appState.currentCardIndex].sections.splice(index, 1);
            renderSections();
            saveState();
        }

        function renderStats() {
            const currentCard = appState.cards[appState.currentCardIndex];
            statsContainer.innerHTML = '';
            const statsToRender = (currentCard.stats && typeof currentCard.stats === 'object') ? currentCard.stats : {};

            Object.entries(statsToRender).forEach(([key, value]) => {
                const statDiv = document.createElement('div');
                statDiv.className = 'flex items-center mb-2';
                statDiv.innerHTML = `
                    <input type="text" value="${key || ''}" readonly class="w-1/3 p-2 rounded-l-md bg-gray-600 border border-gray-500 cursor-not-allowed">
                    <input type="text" data-key="${key || ''}" value="${value || ''}" class="stat-input w-2/3 p-2 rounded-r-md bg-gray-600 border border-gray-500">
                    <button data-key="${key || ''}" class="remove-stat-btn ml-2 bg-red-600 hover:bg-red-700 text-white text-xs font-bold py-1 px-2 rounded-full">X</button>
                `;
                statsContainer.appendChild(statDiv);
            });
            document.querySelectorAll('.stat-input').forEach(input => {
                input.addEventListener('input', handleStatChange);
            });
            document.querySelectorAll('.remove-stat-btn').forEach(button => {
                button.addEventListener('click', handleRemoveStat);
            });
            updateCardPreview();
        }

        function handleStatChange(event) {
            const key = event.target.dataset.key;
            appState.cards[appState.currentCardIndex].stats[key] = event.target.value;
            saveState();
            updateCardPreview();
        }

        function handleRemoveStat(event) {
            const key = event.target.dataset.key;
            delete appState.cards[appState.currentCardIndex].stats[key];
            renderStats();
            saveState();
        }

        function updateCardPreview() {
            const card = appState.cards[appState.currentCardIndex];
            const printerType = appState.printerType;
            const thermalPaperSize = appState.thermalPaperSize;

            const widthClass = thermalPaperSize === '58mm' ? 'w-[48mm]' : 'w-[72mm]';
            const textColor = printerType === 'thermal' ? 'text-black' : 'text-gray-900';
            const bgColor = printerType === 'thermal' ? 'bg-white' : card.color || 'bg-white';
            const borderColor = printerType === 'thermal' ? 'border-gray-400' : 'border-gray-300';

            cardPreviewContainer.className = `p-4 rounded-lg shadow-lg ${bgColor} ${textColor} ${borderColor} border-2 overflow-hidden`;
            previewTitle.textContent = `Card Preview (${printerType === 'thermal' ? 'Monochrome' : 'Color'})`;

            let iconHtml = '';
            if (card.icon) {
                // New logic: First check the manifest for a local icon path
                if (iconManifest[card.icon]) {
                    const iconPath = iconManifest[card.icon];
                    iconHtml = `<img src="${iconPath}" alt="${card.icon}" style="position: absolute; top: 0.125in; right: 0.125in; width: 0.25in; height: 0.25in; object-fit: contain;" class="${printerType === 'thermal' ? 'filter grayscale' : ''}" onerror="this.src='https://placehold.co/48x48/${printerType === 'thermal' ? '000/FFF' : 'E0E0E0/888'}?text=ICON';" />`;
                } else if (isURL(card.icon)) {
                    // Fallback to URL if it's a valid URL
                    iconHtml = `<img src="${card.icon}" alt="Card Icon" style="position: absolute; top: 0.125in; right: 0.125in; width: 0.25in; height: 0.25in; object-fit: contain;" class="${printerType === 'thermal' ? 'filter grayscale' : ''}" onerror="this.src='https://placehold.co/48x48/${printerType === 'thermal' ? '000/FFF' : 'E0E0E0/888'}?text=IMG';" />`;
                } else {
                    // Finally, assume it's a Font Awesome class name
                    iconHtml = `<i class="fa-solid fa-${card.icon} card-icon-fa" style="position: absolute; top: 0.125in; right: 0.125in; font-size: 0.25in; width: 0.25in; height: 0.25in;" class="${printerType === 'thermal' ? 'filter grayscale' : ''}"></i>`;
                }
            }

            cardFrontPreview.className = `relative mx-auto p-2 border border-dashed border-gray-400 rounded-md ${widthClass} min-h-[150px] flex flex-col justify-between`;
            cardFrontPreview.innerHTML = `
                ${iconHtml}
                <div class="flex flex-col items-center mb-2">
                    <h1 class="text-2xl font-extrabold text-center mb-1 leading-tight">${card.title || ''}</h1>
                    ${card.type ? `<p class="text-lg text-center mb-2">${card.type}</p>` : ''}
                </div>

                ${(card.stats && Object.keys(card.stats).length > 0) ? `
                    <div class="flex flex-wrap justify-center text-sm mb-2">
                        ${Object.entries(card.stats).map(([key, value]) => `
                            <span class="mx-2 whitespace-nowrap">
                                <strong class="font-semibold">${key || ''}:</strong> ${value || ''}
                            </span>
                        `).join('')}
                    </div>
                ` : ''}

                <div class="flex-grow overflow-hidden">
                    ${(card.sections && Array.isArray(card.sections)) ? card.sections.map((section, index) => `
                        <div class="mb-2">
                            ${section.heading ? `<h2 class="text-lg font-semibold border-b border-gray-300 pb-1 mb-1">${section.heading}</h2>` : ''}
                            <p class="text-sm leading-snug card-content">${formatText(section.body || '')}</p>
                            ${section.flavorText ? `<p class="text-xs italic text-gray-600 mt-1 card-content">${formatText(section.flavorText || '')}</p>` : ''}
                        </div>
                    `).join('') : ''}
                </div>

                ${(card.tags && Array.isArray(card.tags) && card.tags.length > 0) ? `
                    <p class="text-xs text-center mt-2 border-t border-gray-300 pt-1">Tags: ${card.tags.join(', ')}</p>
                ` : ''}
                ${card.footer ? `<p class="text-xs text-center mt-1">${card.footer || ''}</p>` : ''}
            `;

            if (card.isFolded) {
                cardBackPreviewContainer.classList.remove('hidden');
                cardBackPreview.className = `relative mx-auto p-2 border border-dashed border-gray-400 rounded-md ${widthClass} min-h-[100px] flex flex-col justify-center items-center transform rotate-180`;
                let foldContentHtml = '';
                const foldContent = card.foldContent && typeof card.foldContent === 'object' ? card.foldContent : {};

                if (foldContent.type === 'text' && foldContent.text) {
                    foldContentHtml = `<p class="text-sm text-center card-content">${formatText(foldContent.text)}</p>`;
                } else if (foldContent.type === 'imageUrl' && foldContent.imageUrl) {
                    let backImagePath = foldContent.imageUrl;
                    if (iconManifest[backImagePath]) {
                        backImagePath = iconManifest[backImagePath];
                    }
                    foldContentHtml = `<div style="display: flex; justify-content: center; align-items: center; height: 100%;"><img src="${backImagePath}" alt="Fold Back Image" style="width: 100%; object-fit: contain;" class="${printerType === 'thermal' ? 'filter grayscale' : ''}" onerror="this.src='https://placehold.co/96x96/${printerType === 'thermal' ? '000/FFF' : 'E0E0E0/888'}?text=BACK+IMG';" /></div>`;
                } else if (foldContent.type === 'qrCode' && foldContent.qrCodeData) {
                    foldContentHtml = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=96x96&data=${encodeURIComponent(foldContent.qrCodeData)}" alt="QR Code" class="w-24 h-24 object-contain" onerror="this.src='https://placehold.co/96x96/000/FFF?text=QR';" />`;
                }
                cardBackPreview.innerHTML = foldContentHtml;
            } else {
                cardBackPreviewContainer.classList.add('hidden');
            }
        }

        // Functions for toggling UI elements based on state
        function toggleFoldContentOptions() {
            const currentCard = appState.cards[appState.currentCardIndex];
            if (currentCard.isFolded) {
                foldContentOptions.classList.remove('hidden');
                updateFoldContentInputs();
            } else {
                foldContentOptions.classList.add('hidden');
            }
        }

        function updateFoldContentInputs() {
            foldTextInput.classList.add('hidden');
            foldImageInput.classList.add('hidden');
            foldQrInput.classList.add('hidden');

            const currentCard = appState.cards[appState.currentCardIndex];
            if (currentCard.foldContent.type === 'text') {
                foldTextInput.classList.remove('hidden');
            } else if (currentCard.foldContent.type === 'imageUrl') {
                foldImageInput.classList.remove('hidden');
            } else if (currentCard.foldContent.type === 'qrCode') {
                foldQrInput.classList.remove('hidden');
            }
        }

        function togglePrinterTypeOptions() {
            if (appState.printerType === 'thermal') {
                thermalPaperSizeContainer.classList.remove('hidden');
                thermalDpiContainer.classList.remove('hidden');
                printThermalBtn.classList.remove('hidden');
                printColorPhotoBtn.classList.add('hidden');
            } else {
                thermalPaperSizeContainer.classList.add('hidden');
                thermalDpiContainer.classList.add('hidden');
                printThermalBtn.classList.add('hidden');
                printColorPhotoBtn.classList.remove('hidden');
            }
        }

        // Card Navigation UI Update
        function updateCardNavigationUI() {
            cardSelect.innerHTML = '';
            appState.cards.forEach((card, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = card.title || `Untitled Card ${index + 1}`;
                cardSelect.appendChild(option);
            });
            cardSelect.value = appState.currentCardIndex;

            prevCardBtn.disabled = appState.currentCardIndex === 0;
            nextCardBtn.disabled = appState.currentCardIndex === appState.cards.length - 1;
        }

        // Centralized function to update all UI elements from appState
        function updateUIFromAppState() {
            const currentCard = appState.cards[appState.currentCardIndex];

            titleInput.value = currentCard.title || '';
            typeInput.value = currentCard.type || '';
            iconInput.value = currentCard.icon || ''; // Icon name or URL
            colorInput.value = currentCard.color || '#ffffff';
            tagsInput.value = (currentCard.tags && Array.isArray(currentCard.tags)) ? currentCard.tags.join(', ') : '';
            footerInput.value = currentCard.footer || '';
            isFoldedCheckbox.checked = currentCard.isFolded;
            printerTypeSelect.value = appState.printerType;
            thermalPaperSizeSelect.value = appState.thermalPaperSize;
            thermalDpiSelect.value = appState.thermalDpi;
            numCopiesInput.value = appState.numCopies;

            if (!currentCard.foldContent || typeof currentCard.foldContent !== 'object') {
                currentCard.foldContent = { type: 'text', text: '', imageUrl: '', qrCodeData: '' };
            }
            foldContentTypeSelect.value = currentCard.foldContent.type || 'text';
            foldContentTextarea.value = currentCard.foldContent.text || '';
            foldContentImageUrlInput.value = currentCard.foldContent.imageUrl || '';
            foldContentQrDataInput.value = currentCard.foldContent.qrCodeData || '';

            if (!currentCard.sections || !Array.isArray(currentCard.sections)) {
                currentCard.sections = [];
            }
            if (!currentCard.stats || typeof currentCard.stats !== 'object') {
                currentCard.stats = {};
            }

            renderSections();
            renderStats();
            toggleFoldContentOptions();
            togglePrinterTypeOptions();
            updateCardNavigationUI(); // Update card navigation UI
            updateCardPreview();
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('ttrpgCardPrinterState', JSON.stringify(appState));
            updatePrintLink();
        }

        // Load state from localStorage or URL parameters
        function loadState() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const cardDataParam = urlParams.get('data') || urlParams.get('cardData');

                if (cardDataParam) {
                    const decodedData = JSON.parse(atob(cardDataParam));

                    // Correctly unpack the data from the URL
                    if (decodedData.card) {
                        appState.cards = [decodedData.card];
                    } else {
                        // Fallback for old format or direct card data
                        appState.cards = [decodedData];
                    }
                    appState.currentCardIndex = 0;

                    if (decodedData.settings) {
                        appState.printerType = decodedData.settings.printerType || appState.printerType;
                        appState.thermalPaperSize = decodedData.settings.thermalPaperSize || appState.thermalPaperSize;
                        appState.thermalDpi = decodedData.settings.thermalDpi || appState.thermalDpi;
                        appState.numCopies = decodedData.settings.numCopies || appState.numCopies;
                    }

                    showMessage('Card loaded from URL bookmark!');
                } else {
                    const savedState = localStorage.getItem('ttrpgCardPrinterState');
                    if (savedState) {
                        const parsedState = JSON.parse(savedState);
                        if (parsedState.cards && Array.isArray(parsedState.cards) && parsedState.cards.length > 0) {
                            appState.cards = parsedState.cards;
                            appState.currentCardIndex = parsedState.currentCardIndex || 0;
                            if (appState.currentCardIndex >= appState.cards.length) {
                                appState.currentCardIndex = 0; // Reset if index is out of bounds
                            }
                        }
                        if (parsedState.printerType) appState.printerType = parsedState.printerType;
                        if (parsedState.thermalPaperSize) appState.thermalPaperSize = parsedState.thermalPaperSize;
                        if (parsedState.thermalDpi) appState.thermalDpi = parsedState.thermalDpi;
                        if (parsedState.numCopies) {
                            let loadedNumCopies = parseInt(parsedState.numCopies, 10);
                            if (!isNaN(loadedNumCopies) && loadedNumCopies >= 1 && loadedNumCopies <= 10) {
                                appState.numCopies = loadedNumCopies;
                            } else {
                                appState.numCopies = 1;
                            }
                        }
                        if (parsedState.printScope) appState.printScope = parsedState.printScope;
                        if (parsedState.rememberedIcons) appState.rememberedIcons = parsedState.rememberedIcons;

                    }
                }
            } catch (error) {
                console.error("Error loading state from localStorage or URL:", error);
                // Reset to initial state on error
                appState = {
                    cards: [{
                        id: '', title: 'New Card', type: 'Spell', icon: '', color: '#ffffff', tags: [],
                        sections: [{ heading: 'Description', body: 'This is a magical card.', flavorText: '' }],
                        cost: '', rarity: '', abilities: [], image: '', stats: {}, footer: 'Custom Card',
                        isFolded: false, foldContent: { type: 'text', text: 'Folded content goes here.', imageUrl: '', qrCodeData: '' }
                    }],
                    currentCardIndex: 0,
                    printerType: 'thermal',
                    thermalPaperSize: '58mm',
                    numCopies: 1,
                    printScope: 'current'
                };
                showMessage('Failed to load card data. Starting with a new card.', true);
            }
            updateUIFromAppState();
            populateIconSuggestions();
        }

        // JSON Import Handlers
        rpgCardsJsonFile.addEventListener('change', (e) => handleJsonImport(e, 'rpg-cards'));
        eToolsJsonPaste.addEventListener('input', (e) => handleJsonPaste(e, '5e-tools'));
        genericJsonPaste.addEventListener('input', (e) => handleJsonPaste(e, 'generic'));

        function handleJsonImport(e, type) {
            const file = e.target.files ? e.target.files[0] : null;
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        // If it's an array of cards, use all of them. Otherwise, wrap single object in array.
                        const dataToParse = Array.isArray(importedData) ? importedData : [importedData];
                        parseAndSetCardData(dataToParse, type);
                        showMessage('JSON imported successfully!');
                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                        showMessage('Failed to parse JSON. Please check the format.', true);
                    }
                };
                reader.readAsText(file);
            }
        }

        function handleJsonPaste(e, type) {
            try {
                const pastedData = JSON.parse(e.target.value);
                // If it's an array of cards, use all of them. Otherwise, wrap single object in array.
                const dataToParse = Array.isArray(pastedData) ? pastedData : [pastedData];
                parseAndSetCardData(dataToParse, type);
                showMessage('JSON pasted successfully!');
            } catch (error) {
                console.error('Error parsing JSON:', error);
                showMessage('Failed to parse JSON. Please check the format.', true);
            }
        }

        function parseAndSetCardData(dataArray, type) {
            appState.cards = []; // Clear existing cards
            dataArray.forEach(data => {
                let newCard = {
                    id: crypto.randomUUID(),
                    title: 'New Card',
                    type: 'Spell',
                    icon: '',
                    color: '#ffffff',
                    tags: [],
                    sections: [{ heading: 'Description', body: '', flavorText: '' }],
                    cost: '', rarity: '', abilities: [], image: '', stats: {}, footer: 'Custom Card',
                    isFolded: false, foldContent: { type: 'text', text: '', imageUrl: '', qrCodeData: '' }
                };

                if (type === 'rpg-cards') {
                    newCard.title = data.title || newCard.title;
                    newCard.color = data.color || newCard.color;
                    newCard.icon = data.icon || '';
                    newCard.tags = (data.tags && Array.isArray(data.tags)) ? data.tags : [];

                    newCard.sections = [];
                    newCard.stats = {};
                    newCard.type = '';

                    if (data.contents && Array.isArray(data.contents)) {
                        let currentSection = { heading: '', body: '', flavorText: '' };
                        data.contents.forEach(line => {
                            if (line.startsWith('subtitle | ')) {
                                if (currentSection.body || currentSection.heading || currentSection.flavorText) {
                                    newCard.sections.push({ ...currentSection });
                                }
                                currentSection = { heading: '', body: '', flavorText: '' };
                                newCard.type = line.substring('subtitle | '.length).trim();
                            } else if (line.startsWith('rule')) {
                                if (currentSection.body || currentSection.heading || currentSection.flavorText) {
                                    newCard.sections.push({ ...currentSection });
                                }
                                currentSection = { heading: '', body: '', flavorText: '' };
                            } else if (line.startsWith('text | ')) {
                                const textBody = line.substring('text | '.length).trim();
                                if (currentSection.body) {
                                    currentSection.body += '\n' + textBody;
                                } else {
                                    currentSection.body = textBody;
                                }
                            } else if (line.startsWith('property | ')) {
                                const parts = line.substring('property | '.length).split(' | ');
                                if (parts.length >= 2) {
                                    newCard.stats[parts[0].trim()] = parts[1].trim();
                                }
                            } else if (line.startsWith('section | ')) {
                                if (currentSection.body || currentSection.heading || currentSection.flavorText) {
                                    newCard.sections.push({ ...currentSection });
                                }
                                currentSection = { heading: line.substring('section | '.length).trim(), body: '', flavorText: '' };
                            }
                        });
                        if (currentSection.body || currentSection.heading || currentSection.flavorText) {
                            newCard.sections.push({ ...currentSection });
                        }
                    }

                    if (newCard.sections.length === 0) {
                        newCard.sections.push({ heading: 'Description', body: '', flavorText: '' });
                    }

                    newCard.footer = data.footer || newCard.footer;

                    newCard.isFolded = typeof data.isFolded === 'boolean' ? data.isFolded : false;
                    newCard.foldContent = (data.foldContent && typeof data.foldContent === 'object') ? data.foldContent : { type: 'text', text: '', imageUrl: '', qrCodeData: '' };

                    if (data.icon_back) {
                        newCard.isFolded = true;
                        newCard.foldContent.type = 'imageUrl';
                        newCard.foldContent.imageUrl = data.icon_back;
                    }

                    newCard.numCopies = data.count ? parseInt(data.count, 10) : 1;
                    if (isNaN(newCard.numCopies) || newCard.numCopies < 1 || newCard.numCopies > 10) {
                        newCard.numCopies = 1;
                    }

                } else if (type === '5e-tools') {
                    newCard.title = data.name || newCard.title;
                    newCard.type = data.type || newCard.type;
                    newCard.rarity = data.rarity || newCard.rarity;
                    newCard.cost = data.cost || newCard.cost;

                    const newStats = {};
                    if (data.hp) newStats.HP = data.hp.average || data.hp;
                    if (data.str) newStats.STR = data.str;
                    if (data.dex) newStats.DEX = data.dex;
                    if (data.con) newStats.CON = data.con;
                    if (data.int) newStats.INT = data.int;
                    if (data.wis) newStats.WIS = data.wis;
                    if (data.cha) newStats.CHA = data.cha;
                    if (data.cr) newStats.CR = data.cr;
                    newCard.stats = newStats;

                    const newSections = [];
                    if (data.trait) {
                        data.trait.forEach(t => {
                            newSections.push({ heading: t.name, body: t.entries.join('\n'), flavorText: '' });
                        });
                    }
                    if (data.action) {
                        data.action.forEach(a => {
                            newSections.push({ heading: a.name, body: a.entries.join('\n'), flavorText: '' });
                        });
                    }
                    if (data.description) {
                        newSections.push({ heading: 'Description', body: data.description.entries.join('\n'), flavorText: '' });
                    }
                    newCard.sections = newSections;
                    newCard.numCopies = 1;
                } else { // Generic JSON
                    Object.assign(newCard, data); // Merge data into newCard
                    newCard.tags = (newCard.tags && Array.isArray(newCard.tags)) ? newCard.tags : [];
                    newCard.sections = (newCard.sections && Array.isArray(newCard.sections)) ? newCard.sections : [];
                    newCard.stats = (newCard.stats && typeof newCard.stats === 'object') ? newCard.stats : {};
                    newCard.isFolded = typeof newCard.isFolded === 'boolean' ? newCard.isFolded : false;
                    newCard.foldContent = (newCard.foldContent && typeof newCard.foldContent === 'object') ? newCard.foldContent : { type: 'text', text: '', imageUrl: '', qrCodeData: '' };

                    newCard.numCopies = data.numCopies ? parseInt(data.numCopies, 10) : 1;
                    if (isNaN(newCard.numCopies) || newCard.numCopies < 1 || newCard.numCopies > 10) {
                        newCard.numCopies = 1;
                    }
                }
                appState.cards.push(newCard);
            });

            appState.currentCardIndex = 0; // Always show the first card after import
            updateUIFromAppState();
            saveState();
        }

        function populateIconSuggestions() {
            const suggestionsDatalist = document.getElementById('icon-suggestions');
            const defaultIcons = ['imp-laugh', 'crossed-swords', 'magic-swirl', 'family-tree', 'farmer', 'checkbox-tree'];
            const allSuggestions = [...new Set([...defaultIcons, ...appState.rememberedIcons])];

            suggestionsDatalist.innerHTML = allSuggestions.map(icon => `<option value="${icon}"></option>`).join('');
        }

        function rememberIcon(iconName) {
            if (iconName && !isURL(iconName) && !appState.rememberedIcons.includes(iconName)) {
                appState.rememberedIcons.push(iconName);
                populateIconSuggestions();
                saveState();
            }
        }

        // Event Listeners for main card inputs
        titleInput.addEventListener('input', (e) => { appState.cards[appState.currentCardIndex].title = e.target.value; saveState(); updateCardPreview(); updateCardNavigationUI(); });
        typeInput.addEventListener('input', (e) => { appState.cards[appState.currentCardIndex].type = e.target.value; saveState(); updateCardPreview(); });
        iconInput.addEventListener('input', (e) => {
            appState.cards[appState.currentCardIndex].icon = e.target.value;
            rememberIcon(e.target.value);
            saveState();
            updateCardPreview();
        });
        colorInput.addEventListener('input', (e) => { appState.cards[appState.currentCardIndex].color = e.target.value; saveState(); updateCardPreview(); });
        tagsInput.addEventListener('input', (e) => { appState.cards[appState.currentCardIndex].tags = e.target.value.split(',').map(tag => tag.trim()); saveState(); updateCardPreview(); });
        footerInput.addEventListener('input', (e) => { appState.cards[appState.currentCardIndex].footer = e.target.value; saveState(); updateCardPreview(); });
        numCopiesInput.addEventListener('input', (e) => {
            let val = parseInt(e.target.value, 10);
            if (isNaN(val) || val < 1) val = 1;
            if (val > 10) val = 10;
            appState.numCopies = val; // This is a global setting, not per card for now
            e.target.value = val;
            saveState();
        });

        // Add Section button
        addSectionBtn.addEventListener('click', () => {
            appState.cards[appState.currentCardIndex].sections.push({ heading: '', body: '', flavorText: '' });
            renderSections();
            saveState();
        });

        // Add Stat button
        addStatBtn.addEventListener('click', () => {
            const statKey = prompt("Enter stat name (e.g., HP, STR):");
            if (statKey) {
                appState.cards[appState.currentCardIndex].stats[statKey] = '';
                renderStats();
                saveState();
            }
        });

        // Folded card checkbox
        isFoldedCheckbox.addEventListener('change', (e) => {
            appState.cards[appState.currentCardIndex].isFolded = e.target.checked;
            toggleFoldContentOptions();
            updateCardPreview();
            saveState();
        });

        thermalDpiSelect.addEventListener('change', (e) => {
            appState.thermalDpi = parseInt(e.target.value, 10);
            updateCardPreview();
            saveState();
        });

        // Handle fold content type change
        foldContentTypeSelect.addEventListener('change', (e) => {
            appState.cards[appState.currentCardIndex].foldContent.type = e.target.value;
            updateFoldContentInputs();
            updateCardPreview();
            saveState();
        });

        // Fold content inputs
        foldContentTextarea.addEventListener('input', (e) => { appState.cards[appState.currentCardIndex].foldContent.text = e.target.value; updateCardPreview(); saveState(); });
        foldContentImageUrlInput.addEventListener('input', (e) => {
            appState.cards[appState.currentCardIndex].foldContent.imageUrl = e.target.value;
            rememberIcon(e.target.value);
            updateCardPreview();
            saveState();
        });
        foldContentQrDataInput.addEventListener('input', (e) => { appState.cards[appState.currentCardIndex].foldContent.qrCodeData = e.target.value; updateCardPreview(); saveState(); });

        // Printer type selection
        printerTypeSelect.addEventListener('change', (e) => {
            appState.printerType = e.target.value;
            togglePrinterTypeOptions();
            updateCardPreview();
            saveState();
        });

        // Print Scope Radio Buttons
        printScopeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                appState.printScope = e.target.value;
                saveState();
            });
        });

        // Card Navigation Event Listeners
        prevCardBtn.addEventListener('click', () => {
            if (appState.currentCardIndex > 0) {
                appState.currentCardIndex--;
                updateUIFromAppState();
                saveState();
            }
        });

        nextCardBtn.addEventListener('click', () => {
            if (appState.currentCardIndex < appState.cards.length - 1) {
                appState.currentCardIndex++;
                updateUIFromAppState();
                saveState();
            }
        });

        cardSelect.addEventListener('change', (e) => {
            appState.currentCardIndex = parseInt(e.target.value, 10);
            updateUIFromAppState();
            saveState();
        });

        addNewCardBtn.addEventListener('click', () => {
            const newCard = {
                id: crypto.randomUUID(),
                title: 'New Card',
                type: 'Spell',
                icon: '',
                color: '#ffffff',
                tags: [],
                sections: [{ heading: 'Description', body: 'This is a magical card.', flavorText: '' }],
                cost: '', rarity: '', abilities: [], image: '', stats: {}, footer: 'Custom Card',
                isFolded: false, foldContent: { type: 'text', text: 'Folded content goes here.', imageUrl: '', qrCodeData: '' }
            };
            appState.cards.push(newCard);
            appState.currentCardIndex = appState.cards.length - 1; // Go to the new card
            updateUIFromAppState();
            saveState();
            showMessage('New empty card added!');
        });

        // Import Modal Listeners
        openImportModalBtn.addEventListener('click', () => {
            importModal.classList.remove('hidden');
        });

        closeImportModalBtn.addEventListener('click', () => {
            importModal.classList.add('hidden');
        });

        // Close modal if clicking on the background
        importModal.addEventListener('click', (e) => {
            if (e.target === importModal) {
                importModal.classList.add('hidden');
            }
        });

        // Accordion Logic
        function setupAccordion(button, content) {
            button.addEventListener('click', () => {
                const isHidden = content.classList.toggle('hidden');
                const icon = button.querySelector('i');
                icon.classList.toggle('rotate-180', !isHidden);
            });
        }

        setupAccordion(accordionFileImportHeading, accordionFileImportContent);
        setupAccordion(accordion5eToolsHeading, accordion5eToolsContent);
        setupAccordion(accordionGenericJsonHeading, accordionGenericJsonContent);


        function getPixelWidth(paperSize, dpi) {
            // Based on the table provided in README.md
            // 1 inch = 25.4 mm
            const printableWidthMm = {
                '58mm': 48,
                '80mm': 72
            };
            const printableWidthIn = printableWidthMm[paperSize] / 25.4;
            return Math.round(printableWidthIn * dpi);
        }

        // Generate HTML for thermal printer
        async function generateThermalHtmlForCard(card) {
            const widthPx = getPixelWidth(appState.thermalPaperSize, appState.thermalDpi);
            const baseWidth = 384; // Use 58mm @ 203 DPI as the baseline for scaling
            const scaleFactor = widthPx / baseWidth;

            let iconRenderHtml = '';
            if (card.icon) {
                const iconSize = 24 * scaleFactor; // 0.25in at base resolution
                // New logic: Check manifest first, then URL, then fallback
                if (iconManifest[card.icon]) {
                    const iconPath = iconManifest[card.icon];
                    iconRenderHtml = `<img src="${iconPath}" style="position: absolute; top: ${12 * scaleFactor}px; right: ${12 * scaleFactor}px; width: ${iconSize}px; height: ${iconSize}px; object-fit: contain; filter: grayscale(100%);" onerror="this.src='https://placehold.co/60x60/000/FFF?text=ICON';" />`;
                } else if (isURL(card.icon)) {
                    iconRenderHtml = `<img src="${card.icon}" style="position: absolute; top: ${12 * scaleFactor}px; right: ${12 * scaleFactor}px; width: ${iconSize}px; height: ${iconSize}px; object-fit: contain; filter: grayscale(100%);" onerror="this.src='https://placehold.co/60x60/000/FFF?text=IMG';" />`;
                } else {
                    // Fallback for non-URL, non-manifest icons (e.g., Font Awesome names)
                    iconRenderHtml = `<img src="https://placehold.co/60x60/000/FFF?text=${encodeURIComponent(card.icon.toUpperCase())}" style="position: absolute; top: ${12 * scaleFactor}px; right: ${12 * scaleFactor}px; width: ${iconSize}px; height: ${iconSize}px; object-fit: contain; filter: grayscale(100%);" />`;
                }
            }

            let htmlContent = `
                <div style="position: relative; width: ${widthPx}px; height: ${widthPx * 1.4}px; font-family: 'Inter', sans-serif; padding: ${8 * scaleFactor}px; box-sizing: border-box; color: #000; background-color: #fff; display: flex; flex-direction: column;">
                    ${iconRenderHtml}
                    <div>
                        <h1 style="text-align: center; font-size: ${24 * scaleFactor}px; margin-bottom: ${4 * scaleFactor}px; line-height: 1.2;">${card.title || ''}</h1>
                        ${card.type ? `<p style="text-align: center; font-size: ${16 * scaleFactor}px; margin-bottom: ${8 * scaleFactor}px;">${card.type}</p>` : ''}
                    </div>

                    ${(card.stats && Object.keys(card.stats).length > 0) ? `
                        <div style="display: flex; flex-wrap: wrap; justify-content: center; margin-bottom: ${8 * scaleFactor}px; font-size: ${14 * scaleFactor}px;">
                            ${Object.entries(card.stats).map(([key, value]) => `
                                <span style="margin: 0 ${8 * scaleFactor}px; white-space: nowrap;"><strong>${key || ''}:</strong> ${value || ''}</span>
                            `).join('')}
                        </div>
                    ` : ''}

                    <div style="flex-grow: 1; overflow: hidden; display: flex; flex-direction: column; justify-content: space-around;">
                        ${(card.sections && Array.isArray(card.sections)) ? card.sections.map(section => `
                            <div class="mb-2">
                                ${section.heading ? `<h2 style="font-size: ${18 * scaleFactor}px; margin-bottom: ${4 * scaleFactor}px; border-bottom: 1px dashed #999; padding-bottom: ${2 * scaleFactor}px;">${section.heading}</h2>` : ''}
                                <p style="font-size: ${14 * scaleFactor}px; margin-bottom: ${4 * scaleFactor}px; line-height: 1.4;">${formatText(section.body || '')}</p>
                                ${section.flavorText ? `<p style="font-size: ${12 * scaleFactor}px; font-style: italic; color: #555; margin-top: ${4 * scaleFactor}px;">${formatText(section.flavorText || '')}</p>` : ''}
                            </div>
                        `).join('') : ''}
                    </div>

                    <div>
                        ${(card.tags && Array.isArray(card.tags) && card.tags.length > 0) ? `
                            <p style="font-size: ${12 * scaleFactor}px; text-align: center; margin-top: ${8 * scaleFactor}px; border-top: 1px dashed #999; padding-top: ${4 * scaleFactor}px;">Tags: ${card.tags.join(', ')}</p>
                        ` : ''}

                        ${card.footer ? `<p style="font-size: ${12 * scaleFactor}px; text-align: center; margin-top: ${8 * scaleFactor}px;">${card.footer || ''}</p>` : ''}
                    </div>
                </div>
            `;

            if (card.isFolded) {
                htmlContent += `
                    <div style="width: ${widthPx}px; font-family: 'Inter', sans-serif; padding: ${8 * scaleFactor}px; box-sizing: border-box; color: #000; background-color: #fff; transform: rotate(180deg); transform-origin: center center; display: flex; justify-content: center; align-items: center;">
                        ${(card.foldContent && card.foldContent.type === 'text' && card.foldContent.text) ? `
                            <p style="font-size: ${14 * scaleFactor}px; text-align: center; margin: 0; line-height: 1.4;">${formatText(card.foldContent.text)}</p>
                        ` : ''}
                        ${(card.foldContent && card.foldContent.type === 'imageUrl' && card.foldContent.imageUrl) ? `
                            <img src="${iconManifest[card.foldContent.imageUrl] || card.foldContent.imageUrl}" style="width: 100%; object-fit: contain; filter: grayscale(100%);" onerror="this.src='https://placehold.co/100x100/000/FFF?text=BACK+IMG';" />
                        ` : ''}
                        ${(card.foldContent && card.foldContent.type === 'qrCode' && card.foldContent.qrCodeData) ? `
                            <img src="https://api.qrserver.com/v1/create-qr-code/?size=${100 * scaleFactor}x${100 * scaleFactor}&data=${encodeURIComponent(card.foldContent.qrCodeData)}" style="display: block; margin: 0 auto; max-width: ${80 * scaleFactor}px; height: auto;" onerror="this.src='https://placehold.co/80x80/000/FFF?text=QR';" />
                        ` : ''}
                    </div>
                `;
            }
            return htmlContent;
        }

        // Function to open the card view
        function openCardView(card) {
            const dataToSend = {
                card: card,
                settings: {
                    thermalPaperSize: appState.thermalPaperSize,
                    thermalDpi: appState.thermalDpi,
                    numCopies: appState.numCopies
                }
            };
            const encodedData = btoa(JSON.stringify(dataToSend));
            const url = `index.html?view=card&data=${encodedData}`;
            window.open(url, '_blank');
        }

        // View Card button handler
        viewCardBtn.addEventListener('click', () => {
            showMessage('Opening card view...');
            const cardToView = appState.cards[appState.currentCardIndex];
            openCardView(cardToView);
        });

        function updatePrintLink() {
            const printButton = document.getElementById('print-thermal-btn');
            const isAndroid = /android/i.test(navigator.userAgent);

            if (isAndroid) {
                const cardToPrint = appState.cards[appState.currentCardIndex];
                const dataToSend = {
                    card: cardToPrint,
                    settings: {
                        thermalPaperSize: appState.thermalPaperSize,
                        thermalDpi: appState.thermalDpi,
                        numCopies: appState.numCopies
                    }
                };
                const encodedData = btoa(JSON.stringify(dataToSend));

                const cardViewUrl = new URL('index.html', window.location.href);
                cardViewUrl.searchParams.set('view', 'card');
                cardViewUrl.searchParams.set('data', encodedData);

                const printUrl = `print://escpos.org/escpos/bt/print?srcTp=uri&srcObj=html&numCopies=${appState.numCopies}&src='${cardViewUrl.toString()}'`;
                printButton.href = printUrl;
                printButton.classList.remove('hidden');
            } else {
                printButton.classList.add('hidden');
            }
        }

        // Print Color Photo button handler
        printColorPhotoBtn.addEventListener('click', async () => {
            // This button's primary function is to share with a printer app.
            const dummyFile = new File(["dummy"], "dummy.png", { type: "image/png" });
            if (!navigator.share || !navigator.canShare({ files: [dummyFile] })) {
                showMessage(`Web Share not supported. Please use the "Download Card Image(s)" button and print manually from your photo app.`, true);
                return;
            }

            showMessage('Generating image(s) for color photo printer...');
            const cardsToProcess = appState.printScope === 'all' ? appState.cards : [appState.cards[appState.currentCardIndex]];

            try {
                const files = [];
                for (const card of cardsToProcess) {
                    const canvas = await generateCardCanvas(card);
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    files.push(new File([blob], `${card.title.replace(/\s/g, '_')}_card.png`, { type: 'image/png' }));
                }

                await navigator.share({
                    files: files,
                    title: `Print Card: ${cardsToProcess.length > 1 ? 'Multiple Cards' : cardsToProcess[0].title}`,
                    text: 'Ready to print TTRPG card(s).',
                });
                showMessage('Image(s) sent to share dialog for printing.');
            } catch (error) {
                if (error.name === 'AbortError') {
                    showMessage('Share cancelled.', false);
                } else {
                    console.error('Error preparing image for printing:', error);
                    showMessage(`Error preparing image for printing: ${error.message}`, true);
                }
            }
        });

        // Refactored function to generate a canvas for a given card
        async function generateCardCanvas(card) {
            console.log('--- Generating Card Canvas ---');
            console.log('Printer Type:', appState.printerType);
            console.log('Thermal Paper Size:', appState.thermalPaperSize);
            console.log('Thermal DPI:', appState.thermalDpi);

            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-9999px';
            // Use a specific class to scope the styles and queries
            tempContainer.className = 'card-export-render-container';

            let targetWidthPx, targetHeightPx;
            let htmlContent = '';

            // This logic is mostly extracted from the original download/share buttons
            if (appState.printerType === 'thermal') {
                targetWidthPx = getPixelWidth(appState.thermalPaperSize, appState.thermalDpi);
                targetHeightPx = targetWidthPx * (card.isFolded ? 2.8 : 1.4); // Maintain aspect ratio, account for fold
                // For thermal, we let the content define the height. The container will have two divs.
                tempContainer.style.width = `${targetWidthPx}px`;
                htmlContent = await generateThermalHtmlForCard(card); // This function already produces a complete HTML string
            } else { // 'color' printer type
                targetWidthPx = 600;
                // For folded color cards, the canvas is twice the height of the front (1:1.5 ratio)
                targetHeightPx = card.isFolded ? (targetWidthPx * 1.5 * 2) : (targetWidthPx * 1.5);
                tempContainer.style.width = `${targetWidthPx}px`;
                tempContainer.style.height = `${targetHeightPx}px`;
                tempContainer.style.overflow = 'hidden';

                // Simplified HTML generation for color cards
                let iconHtml = '';
                console.log('Calculated Dimensions (WxH):', targetWidthPx, 'x', targetHeightPx);
                if (card.icon) {
                    const iconUrl = iconManifest[card.icon] || (isURL(card.icon) ? card.icon : `https://placehold.co/48x48/E0E0E0/888?text=ICON`);
                    iconHtml = `<div id="card-export-icon-placeholder" style="position: absolute; top: 20px; right: 20px; width: 60px; height: 60px;"></div>`;
                }

                const frontHtml = `
                    <div class="card-export-front" style="position: relative; width: ${targetWidthPx}px; height: ${targetWidthPx * 1.5}px; font-family: 'Inter', sans-serif; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; align-items: center; text-align: center; background-color: ${card.color || '#ffffff'}; color: #000;">
                        ${iconHtml}
                        <h1 style="font-size: 48px; margin-bottom: 10px; line-height: 1.2;">${card.title || ''}</h1>
                        ${card.type ? `<p style="font-size: 28px; margin-bottom: 15px;">${card.type}</p>` : ''}
                        <div style="flex-grow: 1; overflow: hidden; width: 100%;">
                            ${(card.stats && Object.keys(card.stats).length > 0) ? `
                            <div style="display: flex; flex-wrap: wrap; justify-content: center; margin-bottom: 15px; font-size: 24px;">
                                ${Object.entries(card.stats).map(([key, value]) => `<span style="margin: 0 15px; white-space: nowrap;"><strong>${key || ''}:</strong> ${value || ''}</span>`).join('')}
                            </div>` : ''}
                            ${(card.sections && Array.isArray(card.sections)) ? card.sections.map(section => `
                            <div style="margin-bottom: 15px; text-align: left;">
                                ${section.heading ? `<h2 style="font-size: 32px; margin-bottom: 8px; border-bottom: 2px solid #ccc; padding-bottom: 4px;">${section.heading}</h2>` : ''}
                                <p style="font-size: 24px; margin-bottom: 8px; line-height: 1.4;">${formatText(section.body || '')}</p>
                                ${section.flavorText ? `<p style="font-size: 20px; font-style: italic; color: #555; margin-top: 8px;">${formatText(section.flavorText || '')}</p>` : ''}
                            </div>`).join('') : ''}
                        </div>
                        ${(card.tags && Array.isArray(card.tags) && card.tags.length > 0) ? `<p style="font-size: 20px; text-align: center; margin-top: 15px; border-top: 2px solid #ccc; padding-top: 8px;">Tags: ${card.tags.join(', ')}</p>` : ''}
                        ${card.footer ? `<p style="font-size: 20px; text-align: center; margin-top: 15px;">${card.footer || ''}</p>` : ''}
                    </div>`;

                htmlContent += frontHtml;

                if (card.isFolded) {
                    let backContentHtml = '';
                    const foldContent = card.foldContent || {};
                    if (foldContent.type === 'text' && foldContent.text) {
                        backContentHtml = `<p style="font-size: 28px; margin: 0; line-height: 1.4;">${formatText(foldContent.text)}</p>`;
                    } else if (foldContent.type === 'imageUrl' && foldContent.imageUrl) {
                        const backImgUrl = iconManifest[foldContent.imageUrl] || foldContent.imageUrl;
                        backContentHtml = `<div id="card-export-back-placeholder" style="width: 90%; height: 90%;"></div>`;
                    } else if (foldContent.type === 'qrCode' && foldContent.qrCodeData) {
                        const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(foldContent.qrCodeData)}`;
                        backContentHtml = `<img class="card-export-qr" src="${qrUrl}" style="max-width: 300px; height: auto;" />`;
                    }

                    const backHtml = `
                        <div class="card-export-back" style="width: ${targetWidthPx}px; height: ${targetWidthPx * 1.5}px; font-family: 'Inter', sans-serif; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; background-color: ${card.color || '#ffffff'}; color: #000; transform: rotate(180deg); transform-origin: center center;">
                            ${backContentHtml}
                        </div>`;
                    htmlContent += backHtml;
                }
            }

            tempContainer.innerHTML = htmlContent;
            document.body.appendChild(tempContainer);

            // Add a small delay to allow fonts to render if needed
            await new Promise(resolve => setTimeout(resolve, 100));

            const canvas = await html2canvas(tempContainer, {
                useCORS: true,
                logging: false,
                width: targetWidthPx,
                height: targetHeightPx,
            });

            // Manually draw images onto the canvas to bypass html2canvas rendering bugs
            const ctx = canvas.getContext('2d');

            // 1. Draw the icon
            if (card.icon) {
                const iconUrl = iconManifest[card.icon] || (isURL(card.icon) ? card.icon : null);
                if (iconUrl) {
                    try {
                        const img = await loadImage(iconUrl);
                        const placeholder = tempContainer.querySelector('#card-export-icon-placeholder');
                        const rect = placeholder.getBoundingClientRect();
                        const containerRect = tempContainer.getBoundingClientRect();

                        const x = rect.left - containerRect.left;
                        const y = rect.top - containerRect.top;
                        const width = rect.width;
                        const height = rect.height;

                        const hRatio = width / img.width;
                        const vRatio = height / img.height;
                        const ratio = Math.min(hRatio, vRatio);
                        const centerShiftX = (width - img.width * ratio) / 2;
                        const centerShiftY = (height - img.height * ratio) / 2;

                        ctx.drawImage(img, 0, 0, img.width, img.height, x + centerShiftX, y + centerShiftY, img.width * ratio, img.height * ratio);
                    } catch (e) {
                        console.error("Could not draw icon:", e);
                    }
                }
            }

            // 2. Draw the back image if it exists
            if (card.isFolded && card.foldContent && card.foldContent.type === 'imageUrl' && card.foldContent.imageUrl) {
                const backImgUrl = iconManifest[card.foldContent.imageUrl] || card.foldContent.imageUrl;
                if (backImgUrl) {
                    try {
                        const img = await loadImage(backImgUrl);
                        const placeholder = tempContainer.querySelector('#card-export-back-placeholder');
                        const rect = placeholder.getBoundingClientRect();
                        const containerRect = tempContainer.getBoundingClientRect();

                        const x = rect.left - containerRect.left;
                        const y = rect.top - containerRect.top;
                        const width = rect.width;
                        const height = rect.height;

                        const hRatio = width / img.width;
                        const vRatio = height / img.height;
                        const ratio = Math.min(hRatio, vRatio);
                        const centerShiftX = (width - img.width * ratio) / 2;
                        const centerShiftY = (height - img.height * ratio) / 2;

                        ctx.drawImage(img, 0, 0, img.width, img.height, x + centerShiftX, y + centerShiftY, img.width * ratio, img.height * ratio);
                    } catch (e) {
                        console.error("Could not draw back image:", e);
                    }
                }
            }

            document.body.removeChild(tempContainer);
            return canvas;
        }

        // Download Image button handler
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous'; // Handle CORS
                img.onload = () => resolve(img);
                img.onerror = (err) => reject(err);
                img.src = src;
            });
        }

        function downloadImage(imageDataUrl, cardTitle = 'card') {
            const link = document.createElement('a');
            link.href = imageDataUrl;
            link.download = `${cardTitle.replace(/\s/g, '_')}_${appState.printerType}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage(`Card image "${cardTitle}" downloaded!`);
        }

        downloadImageBtn.addEventListener('click', async () => {
            showMessage('Generating image(s) for download...');
            const cardsToProcess = appState.printScope === 'all' ? appState.cards : [appState.cards[appState.currentCardIndex]];
            const originalCardIndex = appState.currentCardIndex;

            for (const card of cardsToProcess) {
                // This loop doesn't need to update the main UI, just process cards.
                try {
                    const canvas = await generateCardCanvas(card);
                    const imageDataUrl = canvas.toDataURL('image/png');
                    downloadImage(imageDataUrl, card.title); // Use existing helper to download
                } catch (error) {
                    console.error(`Error generating image for download for "${card.title}":`, error);
                    showMessage(`Failed to generate image for download for "${card.title}".`, true);
                }
                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between downloads
            }

            // Restore original state just in case, though we didn't change it.
            appState.currentCardIndex = originalCardIndex;
            updateCardPreview();
            showMessage('Image download process completed for selected cards.');
        });

        // Share Card button handler
        shareCardBtn.addEventListener('click', async () => {
            const dummyFile = new File(["dummy"], "dummy.png", { type: "image/png" });
            if (!navigator.share || !navigator.canShare({ files: [dummyFile] })) {
                showMessage('Web Share API for files not supported on this device/browser. Please download the image and share manually.', true);
                return;
            }

            showMessage('Preparing card(s) for sharing...');
            try {
                const cardsToProcess = appState.printScope === 'all' ? appState.cards : [appState.cards[appState.currentCardIndex]];
                const files = [];

                for (const card of cardsToProcess) {
                    const canvas = await generateCardCanvas(card);
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    files.push(new File([blob], `${card.title.replace(/\s/g, '_')}_card.png`, { type: 'image/png' }));
                }

                showMessage('Ready to share. Opening share dialog...');
                await navigator.share({
                    files: files,
                    title: 'TTRPG Cards',
                    text: 'Here are the TTRPG cards I made.',
                });
                showMessage('Card(s) shared successfully!');
            } catch (error) {
                if (error.name === 'AbortError') {
                    showMessage('Share cancelled.', false);
                } else {
                    console.error('Error sharing files:', error);
                    showMessage(`Error sharing: ${error.message}`, true);
                }
            }
        });

        // Copy Bookmarkable Link button handler
        copyBookmarkLinkBtn.addEventListener('click', () => {
            const currentCard = appState.cards[appState.currentCardIndex];
            const dataToSend = {
                card: currentCard,
                settings: {
                    thermalPaperSize: appState.thermalPaperSize,
                    thermalDpi: appState.thermalDpi,
                    numCopies: appState.numCopies
                }
            };
            const encodedData = btoa(JSON.stringify(dataToSend));

            const currentUrl = new URL(window.location.href);
            // Clear existing params to create a clean link for the editor view
            currentUrl.search = '';
            currentUrl.searchParams.set('data', encodedData); // Use 'data' to be handled by loadState

            const bookmarkLink = currentUrl.toString();

            navigator.clipboard.writeText(bookmarkLink)
                .then(() => {
                    showMessage('Bookmarkable link copied to clipboard!');
                })
                .catch(err => {
                    console.error('Failed to copy bookmark link: ', err);
                    showMessage('Failed to copy link. Please copy manually: ' + bookmarkLink, true);
                });
        });

        async function initGeneratorView() {
            try {
                const response = await fetch('./icon-lookup.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                iconManifest = await response.json();
                console.log('Icon manifest loaded successfully.');
            } catch (error) {
                console.error('Could not load icon manifest:', error);
                showMessage('Could not load local icons. Please check the console for details.', true);
            }
            loadState();
        }

        async function initCardView() {
            // Clean up the UI for a print-only view
            const mainView = document.getElementById('main-generator-view');
            if (mainView) mainView.remove();
            const cardView = document.getElementById('card-view');
            document.body.style.backgroundColor = '#ffffff';
            document.body.style.padding = '0';
            document.body.style.margin = '0';
            cardView.classList.remove('hidden');
            cardView.innerHTML = '<div id="card-render-area"></div>';


            // Fetch the icon manifest, which is necessary for rendering the card
            try {
                const response = await fetch('./icon-lookup.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                iconManifest = await response.json();
            } catch (error) {
                console.error('Could not load icon manifest:', error);
                document.body.innerHTML = '<p>Error: Could not load icon manifest.</p>';
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const dataParam = urlParams.get('data') || urlParams.get('cardData');
            if (!dataParam) {
                document.body.innerHTML = '<p>Error: No card data provided in URL.</p>';
                return;
            }

            try {
                const decodedString = atob(dataParam);
                const decodedData = JSON.parse(decodedString);

                const card = decodedData.card || decodedData;
                const settings = decodedData.settings || {
                    thermalPaperSize: urlParams.get('thermalPaperSize') || '58mm',
                    thermalDpi: parseInt(urlParams.get('thermalDpi'), 10) || 203,
                    numCopies: parseInt(urlParams.get('numCopies'), 10) || 1
                };

                appState.thermalPaperSize = settings.thermalPaperSize;
                appState.thermalDpi = settings.thermalDpi;

                const cardRenderArea = document.getElementById('card-render-area');
                cardRenderArea.innerHTML = await generateThermalHtmlForCard(card);

            } catch (error) {
                console.error('Error processing card view data:', error);
                document.body.innerHTML = `<p>Error: Could not read card data. ${error.message}</p>`;
            }
        }

        // Initial load and render
        window.addEventListener('load', async () => {
            const urlParams = new URLSearchParams(window.location.search);
            const viewMode = urlParams.get('view');

            if (viewMode === 'card') {
                await initCardView();
            } else {
                // This handles both normal page loads and bookmarked links with data
                await initGeneratorView();
            }
        });
    </script>
</body>
</html>
